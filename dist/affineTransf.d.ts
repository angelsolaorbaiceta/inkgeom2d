import Angle from './angle';
import Arc from './arc';
import Line from './line';
import Polygon from './polygon';
import Projectable from './projectable';
import { QuadEqSolution } from './quadraticEqSolution';
import Rect from './rect';
import Segment from './segment';
import Size from './size';
import Vector from './vector';
export default class AffineTransf {
    readonly sx: number;
    readonly sy: number;
    readonly shx: number;
    readonly shy: number;
    readonly tx: number;
    readonly ty: number;
    get determinant(): number;
    get netScale(): number;
    get translation(): Vector;
    get eigenValues(): QuadEqSolution;
    get base(): [Vector, Vector];
    get rotatedAngle(): Angle;
    static readonly identity: AffineTransf;
    static readonly flipY: AffineTransf;
    constructor(sx?: number, sy?: number, tx?: number, ty?: number, shx?: number, shy?: number);
    applyToPoint({ x, y }: Projectable): Vector;
    applyToSegment(segment: Segment): Segment;
    applyToLine(line: Line): Line;
    applyToVector({ x, y }: Projectable): Vector;
    applyToPolygon(poly: Polygon): Polygon;
    applyToRect(rect: Rect): Polygon;
    applyToAngle(angle: Angle): Angle;
    applyToArc(arc: Arc): Arc;
    applyToSize({ width, height }: Size): Size;
    append(other: AffineTransf): AffineTransf;
    prepend(other: AffineTransf): AffineTransf;
    inverse(): AffineTransf;
    asLinear(): AffineTransf;
    toSVGMatrix(): string;
    toSCSSatrix(): string;
    private styleOrderedTerms;
    equals(other: AffineTransf): boolean;
}

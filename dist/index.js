!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).inkgeom2d={})}(this,(function(t){"use strict";var e={areCloseEnough:(t,e,s=1e-10)=>Math.abs(t-e)<s,isCloseToOne(t,e=1e-10){return this.areCloseEnough(t,1,e)},isCloseToZero(t,e=1e-10){return this.areCloseEnough(t,0,e)},zeroOrNumber(t,e=1e-10){return this.isCloseToZero(t,e)?0:t},roundDecimals:(t,e)=>+t.toFixed(e),divideInIntegerParts(t,e){if(e<1)throw new Error(`Expected the number of divisions (${e}) to be a positive number`);if(!Number.isInteger(e))throw new Error(`Expected the number of divisions (${e}) to be an integer number`);const s=Math.floor(t/e),i=t-s*(e-1);return[...Array(e-1).fill(s),i]},clamp:(t,e,s)=>t>e&&t<s?t:t<e?e:s};const s=Object.freeze({x:0,y:0});var i;(i=t.Quadrant||(t.Quadrant={}))[i.First=1]="First",i[i.Second=2]="Second",i[i.Third=3]="Third",i[i.Fourth=4]="Fourth";const n=2*Math.PI,r=.25*Math.PI,o=.5*Math.PI,h=1.5*Math.PI;class a{constructor(t,e){this.radians=t,this.degrees=e}get positiveRadians(){return this.radians<0?n+this.radians:this.radians}get positiveDegrees(){return this.degrees<0?360+this.degrees:this.degrees}get quadrant(){const e=this.positiveRadians;return e>=0&&e<o?t.Quadrant.First:e>=o&&e<Math.PI?t.Quadrant.Second:e>=Math.PI&&e<h?t.Quadrant.Third:t.Quadrant.Fourth}static fromRadians(t){const e=t>n?t%n:t;return new a(e,function(t){return 180*t/Math.PI}(e))}static fromDegrees(t){const e=t>360?t%360:t;return new a(function(t){return t*Math.PI/180}(e),e)}opposite(){return new a(-this.radians,-this.degrees)}asVector(){return new c(Math.cos(this.radians),Math.sin(this.radians))}cos(){return Math.cos(this.radians)}sin(){return Math.sin(this.radians)}sign(){return Math.sign(this.radians)}asSequence(t){const e=this.radians/t;return Array.from({length:t},((t,s)=>a.fromRadians(e*(s+1))))}plus(t){return a.fromRadians(this.radians+t.radians)}equals(t){return e.areCloseEnough(this.radians%n,t.radians%n)}}a.zero=new a(0,0),a.piQuar=a.fromRadians(r),a.piHalf=a.fromRadians(o),a.minusPiHalf=a.fromRadians(-o),a.pi=a.fromRadians(Math.PI),a.twoPi=a.fromRadians(n);class c{constructor(t,e){this.x=t,this.y=e}get length(){return this._length||(this._length=Math.sqrt(this.x*this.x+this.y*this.y)),this._length}get isUnit(){return e.isCloseToOne(this.length)}get isZero(){return e.isCloseToZero(this.length)}get angleWithHorizontal(){return c.iVersor.angleTo(this)}get angleWithVertical(){return c.jVersor.angleTo(this)}static withRoundCoords(t,e){return new c(Math.round(t),Math.round(e))}static fromProjectable(t){return t instanceof c?t:new c(t.x,t.y)}normalized(){if(this.isUnit)return this;const t=this.length;return new c(this.x/t,this.y/t)}distanceTo(t){return function(t,e){const s=t.x-e.x,i=t.y-e.y;return Math.sqrt(s*s+i*i)}(this,t)}displaced(t,e=1){const s=t.scaledBy(e);return this.plus(s)}scaledBy(t){return new c(t*this.x,t*this.y)}scaledToLength(t){return this.normalized().scaledBy(t)}plus(t){return new c(this.x+t.x,this.y+t.y)}minus(t){return new c(this.x-t.x,this.y-t.y)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}isParallelTo(t){return e.isCloseToZero(this.cross(t))}isPerpendicularTo(t){return e.isCloseToZero(this.dot(t))}angleTo(t){const e=Math.acos(this.dot(t)/(this.length*t.length)),s=Math.sign(this.cross(t));return a.fromRadians(s*e)}perpendicular(){return new c(-this.y,this.x)}opposite(){return new c(-this.x,-this.y)}roundedCoords(){return c.withRoundCoords(this.x,this.y)}projectedOver(t){return this.dot(t.normalized())}asAngle(){return this.angleWithHorizontal}rotated(t){const e=t.cos(),s=t.sin();return new c(this.x*e-this.y*s,this.x*s-this.y*e)}equals({x:t,y:s}){return e.areCloseEnough(this.x,t)&&e.areCloseEnough(this.y,s)}}c.origin=new c(0,0),c.iVersor=new c(1,0),c.minusIVersor=new c(-1,0),c.jVersor=new c(0,1),c.minusJVersor=new c(0,-1);const d=Object.freeze({hasIntersection:!1}),u=Object.freeze({hasIntersection:!1});class l{constructor(t,e){this.base=t,this.direction=e,this.directionVersor=e.normalized()}get isHorizontal(){return e.isCloseToZero(this.direction.y)}get isVertical(){return e.isCloseToZero(this.direction.x)}get yIntercept(){if(this.isVertical)return;const{x:t,y:e}=this.base,{x:s,y:i}=this.direction;return e-t*(i/s)}get xIntercept(){if(this.isHorizontal)return;const{x:t,y:e}=this.base,{x:s,y:i}=this.direction;return t-e*(s/i)}isParallelTo(t){return this.direction.isParallelTo(t.direction)}isPerpendicularTo(t){return this.direction.isPerpendicularTo(t.direction)}intersectionWith(t){if(this.isParallelTo(t))return d;const{x:e,y:s}=t.direction,{x:i,y:n}=t.base.minus(this.base),r=(i*s-n*e)/this.direction.cross(t.direction);return Object.freeze({hasIntersection:!0,point:this.base.displaced(this.direction,r)})}xAtY(t){const e=this.xIntercept;if(void 0===e)return;return e+this.direction.x/this.direction.y*t}yAtX(t){const e=this.yIntercept;if(void 0===e)return;return e+this.direction.y/this.direction.x*t}equals(t){return this.base.equals(t.base)&&this.directionVersor.equals(t.directionVersor)}}const g={makeVertical:t=>new l(new c(t,0),m.vVersor),makeHorizontal:t=>new l(new c(0,t),m.uVersor),makeBetween:(t,e)=>new l(new c(t.x,t.y),m.makeBetween(t,e))};function y(t,e){if(t.length!==e.length)throw new Error("Arrays should have the same size in order to be zipped");return(s=t.length,[...Array(s).keys()]).map((s=>[t[s],e[s]]));var s}const m={uVersor:new c(1,0),vVersor:new c(0,1),makeBetween:(t,e)=>new c(e.x-t.x,e.y-t.y),makeUnitBetween:(t,e)=>m.makeBetween(t,e).normalized(),pointHalfWay:(t,e)=>new c(.5*(t.x+e.x),.5*(t.y+e.y)),bisector:(t,e)=>t.normalized().plus(e.normalized()),compare:(t,s)=>e.areCloseEnough(t.x,s.x)?e.areCloseEnough(t.y,s.y)?0:t.y-s.y:t.x-s.x,sorted:t=>t.sort(m.compare),startingAt:t=>({withDirection:e=>({andLength(s){const i=e.normalized();return t.displaced(i,s)},andXCoord(s){const i=g.makeVertical(s);return new l(t,e).intersectionWith(i).point},andYCoord(s){const i=g.makeHorizontal(s);return new l(t,e).intersectionWith(i).point}})}),orthonormalizeBase(t,e){const s=t.scaledToLength(e.projectedOver(t)),i=e.minus(s);return[t.normalized(),i.normalized()]},divideInIntegerParts:(t,s)=>y(e.divideInIntegerParts(t.x,s),e.divideInIntegerParts(t.y,s)).map((([t,e])=>new c(null!=t?t:0,null!=e?e:0)))};var p={sort:t=>t.sort(((t,e)=>t.radians-e.radians))};class x{constructor(t){if(!x.isValid(t))throw new Error(`Expected ${t} to be between 0 and 1`);this.value=t}get percentage(){return 100*this.value/1}static isValid(t){return t>=0&&t<=1}static tryMake(t){return new x(t)}static makeValid(t){return new x(e.clamp(t,0,1))}}x.min=new x(0),x.middle=new x(.5),x.max=new x(1);const w=Object.freeze({width:0,height:0});function f(t){const e=t.length,s=[];for(let i=0;i<e;i++)s.push([t[i],t[(i+1)%e]]);return s}class T{constructor(t){if(t.length<3)throw new Error("Can't construct polygon with less than three vectices");this.vertices=t,this.vertexCount=t.length}get sides(){return this._sides||(this._sides=f(this.vertices).map((([t,e])=>new M(t,e)))),this._sides}get rectBounds(){return this._rectBounds||(this._rectBounds=b.makeContainingPointsAndMargin(this.vertices,1)),this._rectBounds}containsPoint(t){if(!this.rectBounds.containsPoint(t))return!1;const s=this.vertices.map((e=>m.makeBetween(t,e)));if(s.some((t=>t.isZero)))return!0;const i=f(s).map((([t,e])=>t.angleTo(e))).reduce(((t,e)=>t.plus(e)),a.zero).radians;return e.areCloseEnough(Math.abs(i),a.twoPi.radians)}hasIntersectionWithSegment(t){return this.sides.some((e=>e.intersectionWithSegment(t).hasIntersection))}intersectionWithSegment(t){const e=this.sides.map((e=>e.intersectionWithSegment(t))).filter((t=>t.hasIntersection&&t.point)).map((t=>t.point));return{hasIntersection:(s=e,!(0===s.length)),points:e};var s}containsSegment(t){const e=this.containsPoint(t.start)&&this.containsPoint(t.end)&&!this.hasIntersectionWithSegment(t);return{partially:this.hasIntersectionWithSegment(t)||e,completely:e}}}class P{constructor(t,e){this.origin=c.fromProjectable(t),this.size=e,this.left=t.x,this.right=t.x+e.width,this.bottom=t.y,this.top=t.y+e.height}get area(){return this.size.width*this.size.height}get perimeter(){return 2*(this.size.width+this.size.height)}get center(){return{x:this.origin.x+.5*this.size.width,y:this.origin.y+.5*this.size.height}}get corner(){return{x:this.right,y:this.bottom}}static make(t,e,s,i){return new P({x:t,y:e},{width:s,height:i})}containsPoint({x:t,y:e}){return t>this.left&&t<this.right&&e>this.bottom&&e<this.top}containsSegment({start:t,end:e}){return this.containsPoint(t)&&this.containsPoint(e)}intersectionWithLine(t){if(t.isHorizontal){const{y:e}=t.base;return e<this.bottom||e>this.top?[]:[new c(this.left,e),new c(this.right,e)]}if(t.isVertical){const{x:e}=t.base;return e<this.left||e>this.right?[]:[new c(e,this.bottom),new c(e,this.top)]}const e=[],s=t.yAtX(this.left);s&&s>this.bottom&&s<this.top&&e.push(new c(this.left,s));const i=t.yAtX(this.right);i&&i>this.bottom&&i<this.top&&e.push(new c(this.right,i));const n=t.xAtY(this.bottom);n&&n>this.left&&n<this.right&&e.push(new c(n,this.bottom));const r=t.xAtY(this.top);return r&&r>this.left&&r<this.right&&e.push(new c(r,this.top)),e}intersectionSegmentWithLine(t){const[e,s]=this.intersectionWithLine(t);if(e&&s)return new M(e,s)}toPolygon(){return new T([this.origin,new c(this.right,this.bottom),new c(this.right,this.top),new c(this.left,this.top)])}}P.nil=new P(s,w);const b={makeContainingPoints(t){if(t.length<1)throw new Error("Can't create rect containing less than one point");let[e,s]=[t[0].x,t[0].x],[i,n]=[t[0].y,t[0].y];return t.forEach((t=>{e=Math.min(e,t.x),s=Math.max(s,t.x),i=Math.min(i,t.y),n=Math.max(n,t.y)})),new P({x:e,y:i},{width:s-e,height:n-i})},makeContainingPointsAndMargin(t,e){const s=b.makeContainingPoints(t);return new P({x:s.origin.x-e,y:s.origin.y-e},{width:2*e+s.size.width,height:2*e+s.size.height})},makeIncludingPoints:(t,e)=>t===P.nil?b.makeContainingPoints(e):b.makeContainingPoints([...e,t.origin,t.corner]),makeRectCentered(t,e,s){const i={x:t.x-.5*e,y:t.y-.5*s};return new P(i,{width:e,height:s})}};class z{constructor(t,e){this.center=c.fromProjectable(t),this.radius=e}containsPoint(t){return this.center.distanceTo(t)<this.radius}scaled(t){return new z(this.center,t*this.radius)}}const V=Object.freeze({contains:!1});class M{constructor(t,e){this.start=t,this.end=e,this.middle=new c(.5*(t.x+e.x),.5*(t.y+e.y)),this.length=t.distanceTo(e),this.width=Math.abs(e.x-t.x),this.height=Math.abs(e.y-t.y),this.directionVector=m.makeBetween(t,e),this.directionVersor=m.makeUnitBetween(t,e),this.normalVersor=this.directionVersor.perpendicular()}get rectBounds(){return b.makeContainingPoints([this.start,this.end])}get circleBounds(){return new z(this.middle,.5*this.length)}static makeBetween({x:t,y:e},{x:s,y:i}){return new M(new c(t,e),new c(s,i))}asLine(){return new l(this.start,this.directionVector)}pointAt(t){return this.start.displaced(this.directionVector,t.value)}parallelAtDistance(t){return new M(this.start.displaced(this.normalVersor,t),this.end.displaced(this.normalVersor,t))}withOrderedPoints(){return m.compare(this.start,this.end)<=0?this:new M(this.end,this.start)}closestPointTo(t){const e=m.makeBetween(this.start,t).projectedOver(this.directionVersor);return e<0?{point:this.start,t:x.min}:e>this.length?{point:this.end,t:x.max}:{point:this.start.displaced(this.directionVersor,e),t:x.tryMake(e/this.length)}}distanceToPoint(t){const{point:e}=this.closestPointTo(t);return e.distanceTo(t)}containsPoint(t,e=1e-5){const{point:s,t:i}=this.closestPointTo(t);return s.distanceTo(t)>e?V:Object.freeze({contains:!0,t:i,point:s})}equals(t){return this.start.equals(t.start)&&this.end.equals(t.end)}intersectionWithSegment(t){const e=this.directionVector,s=t.directionVector;if(e.isParallelTo(s))return u;const i=e.cross(s),n=t.start.minus(this.start),r=(n.x*s.y-n.y*s.x)/i,o=(n.x*e.y-n.y*e.x)/i;if(x.isValid(r)&&x.isValid(o)){const t=x.tryMake(r),e=x.tryMake(o);return Object.freeze({hasIntersection:!0,point:this.pointAt(t),t1:t,t2:e})}return u}intersectionWithLine(t){const{point:e}=this.asLine().intersectionWith(t);if(!e)return u;const{contains:s,t:i}=this.containsPoint(e);return s&&i?Object.freeze({hasIntersection:!0,point:e,t1:i}):u}split(t){const e=this.pointAt(t);return[new M(this.start,e),new M(e,this.end)]}}class C{constructor(t,e,s,i){this.center=t,this.radius=e,this.start=s,this.end=i;const n=s.asVector().scaledToLength(e),r=t.displaced(n);this.startSegment=new M(t,r);const o=i.asVector().scaledToLength(e),h=t.displaced(o);this.endSegment=new M(t,h)}get startPoint(){return this.startSegment.end}get endPoint(){return this.endSegment.end}get angleFromEndToStart(){const t=this.startSegment.directionVersor;return this.endSegment.directionVersor.angleTo(t)}get angleFromStartToEnd(){const t=this.startSegment.directionVersor,e=this.endSegment.directionVersor;return t.angleTo(e)}get startPointNormalDir(){return this.startSegment.directionVersor.rotated(this.angleFromEndToStart.sign()>0?a.piHalf:a.minusPiHalf)}get endPointNormalDir(){return this.endSegment.directionVersor.rotated(this.angleFromStartToEnd.sign()>0?a.piHalf:a.minusPiHalf)}equals(t){return this.center.equals(t.center)&&e.areCloseEnough(this.radius,t.radius)&&this.start.equals(t.start)&&this.end.equals(t.end)}}class S{constructor(t,e){this.re=t,this.im=e,this.magnitude=Math.sqrt(Math.pow(t,2)+Math.pow(e,2)),this.angle=a.fromRadians(Math.atan(e/t))}}class k{constructor(t=1,s=1,i=0,n=0,r=0,o=0){this.sx=e.zeroOrNumber(t),this.sy=e.zeroOrNumber(s),this.tx=e.zeroOrNumber(i),this.ty=e.zeroOrNumber(n),this.shx=e.zeroOrNumber(r),this.shy=e.zeroOrNumber(o)}get determinant(){return this.sx*this.sy-this.shx*this.shy}get netScale(){return Math.sqrt(Math.abs(this.determinant))}get translation(){return new c(this.tx,this.ty)}get eigenValues(){return function(t,e,s){const i=Math.pow(e,2)-4*t*s,n=2*t;if(i>0){const t=Math.sqrt(i);return{one:(-e+t)/n,two:(-e-t)/n}}if(i<0){const t=-e/n,s=Math.sqrt(-i)/n;return{one:new S(t,s),two:new S(t,-s)}}return{one:-e/n}}(1,-(this.sx+this.sy),this.sx*this.sy-this.shx*this.shy)}get base(){return[new c(this.sx,this.shy),new c(this.shx,this.sy)]}get rotatedAngle(){return this.base[0].angleWithHorizontal}applyToPoint({x:t,y:e}){return new c(t*this.sx+e*this.shx+this.tx,t*this.shy+e*this.sy+this.ty)}applyToSegment(t){return new M(this.applyToPoint(t.start),this.applyToPoint(t.end))}applyToLine(t){return new l(this.applyToPoint(t.base),this.applyToVector(t.direction))}applyToVector({x:t,y:e}){return new c(t*this.sx+e*this.shx,t*this.shy+e*this.sy)}applyToPolygon(t){return new T(t.vertices.map((t=>this.applyToPoint(t))))}applyToRect(t){return this.applyToPolygon(t.toPolygon())}applyToAngle(t){return this.applyToVector(t.asVector()).asAngle()}applyToArc(t){return new C(this.applyToPoint(t.center),this.netScale*t.radius,this.applyToAngle(t.start),this.applyToAngle(t.end))}applyToSize({width:t,height:e}){return Object.freeze({width:t*Math.abs(this.sx),height:e*Math.abs(this.sy)})}append(t){return new k(t.sx*this.sx+t.shx*this.shy,t.shy*this.shx+t.sy*this.sy,t.sx*this.tx+t.shx*this.ty+t.tx,t.shy*this.tx+t.sy*this.ty+t.ty,t.sx*this.shx+t.shx*this.sy,t.shy*this.sx+t.sy*this.shy)}prepend(t){return t.append(this)}inverse(){const t=this.sx*this.sy-this.shx*this.shy;return new k(this.sy/t,this.sx/t,(this.ty*this.shx-this.sy*this.tx)/t,(this.tx*this.shy-this.sx*this.ty)/t,-this.shx/t,-this.shy/t)}asLinear(){return e.isCloseToZero(this.tx)&&e.isCloseToZero(this.ty)?this:new k(this.sx,this.sy,0,0,this.shx,this.shy)}toSVGMatrix(){return`matrix(${this.styleOrderedTerms().join(" ")})`}toSCSSatrix(){return`matrix(${this.styleOrderedTerms().join(", ")})`}styleOrderedTerms(){const t=this.sx.toFixed(3),e=this.sy.toFixed(3),s=this.tx.toFixed(3),i=this.ty.toFixed(3),n=this.shx.toFixed(3);return[t,this.shy.toFixed(3),n,e,s,i]}equals(t){return e.areCloseEnough(this.sx,t.sx)&&e.areCloseEnough(this.sy,t.sy)&&e.areCloseEnough(this.tx,t.tx)&&e.areCloseEnough(this.ty,t.ty)&&e.areCloseEnough(this.shx,t.shx)&&e.areCloseEnough(this.shy,t.shy)}}k.identity=new k,k.flipY=new k(1,-1);const v={makeTranslation:(t,e)=>new k(1,1,t,e),makeScaling(t,e,s=c.origin){const i=s.x*(1-t),n=s.y*(1-e);return new k(t,e,i,n)},makeRotation(t,e=c.origin){const s=t.cos(),i=t.sin(),n=1-s;return new k(s,s,e.x*n+e.y*i,e.y*n-e.x*i,-i,i)},makeToFitRectInside(t,e,s=1){const{x:i,y:n}=m.makeBetween(t.center,e.center),r=v.makeTranslation(i,n),o=s*Math.min(e.size.width/t.size.width,e.size.height/t.size.height),h=v.makeScaling(o,o,e.center);return r.append(h)},combineSequences(t,e){if(t.length!==e.length)throw new Error("Sequences should have the same length to be combined");return s=(t,e)=>t.append(e),y(t,e).map((([t,e])=>s(t,e)));var s}};t.AffineTransf=k,t.Angle=a,t.Arc=C,t.Circle=z,t.Line=l,t.Polygon=T,t.Rect=P,t.Segment=M,t.TParam=x,t.Vector=c,t.angles=p,t.lineLineNoIntersection=d,t.lines=g,t.nilSize=w,t.numbers=e,t.origin=s,t.rects=b,t.roundProjections=function(t){return{x:Math.round(t.x),y:Math.round(t.y)}},t.segSegNoIntersection=u,t.transforms=v,t.vectors=m,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=index.js.map
